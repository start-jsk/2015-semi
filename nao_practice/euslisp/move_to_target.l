(load "kick.l")

(ros::load-ros-manifest "jsk_recognition_msgs")

(defvar *topic-name* "/camera/depth_registered/boxes")
(defvar *bounding-box-list* nil)
(defvar target nil)
(defvar found 0)
(defvar neckstate 0)

(ros::roseus "boundingboxarray_subscriber")

(setq l (instance ros::transform-listener :init))

(defun dist (gbx)
  (sqrt (+ (* (elt (send gbx :pos) 0) (elt (send gbx :pos) 0)) (* (elt (send gbx :pos) 1) (elt (send gbx :pos) 1)))))

(defun bounding-box-array-cb (msg)
  (setq *bounding-box-list* (send msg :boxes))
  (when *bounding-box-list*
	(send *irtviewer* :draw-objects :flush nil)
	(setq target nil)
	(setq footpos (elt (send *nao* :rleg :end-coords :worldpos) 2))
	(if (> footpos (elt (send *nao* :lleg :end-coords :worldpos) 2))
	  (setq footpos (elt (send *nao* :lleg :end-coords :worldpos) 2)))
	(mapcar #'(lambda (b)
				(let* ()
					(setq dims (ros::tf-point->pos (send b :dimensions)))
					   (setq bx (make-cube (elt dims 0) (elt dims 1) (elt dims 2)))
					   (setq tm (ros::time 0))
;;					   	(print (send msg :header :frame_id))
					   (setq cam-coords (send l :lookup-transform "torso" (send msg :header :frame_id) tm))
					   (setq cam->obj-coords (ros::tf-pose->coords (send b :pose)))
;;					(send cam-coords :draw-on :flush nil :size 1000 :color #f(0 0 1))
					(when cam-coords
					  (send bx :newcoords (send cam->obj-coords :transform cam-coords :world))
					  (send bx :worldcoords)
					  (if (> 50 (abs (- (elt (send bx :pos) 2) footpos)))
					  	(progn (send bx :draw-on :flush nil :color #f(1 0 0))
							   (if (equal target nil)
								 (setq target bx)
								 (progn (if (< (dist bx) (dist target))
										  (setq target bx))))
							   )))
					bx))
			*bounding-box-list*)
	(print target)
	(if (equal target nil)
	  (progn (print "not found")
			 (if (equal found 1)
			   (progn (kick)
					  (setq found 0)
					  (nao-default-pose)
					  (lookaround))))
	  (progn (setq found 1)
			 (send *nao* :reset-pose)
			 (lookaround)
			 (send *ri* :angle-vector (send *nao* :angle-vector))
			 (send *ri* :go-pos (* (/ (elt (send target :pos) 0) 1000) 0.6) (* (+ (/ (elt (send target :pos) 1) 1000) 0.15) 1) 0)
			 (send *ri* :wait-interpolation)))
	(send *irtviewer* :viewer :viewsurface :flush)
	)
  (unless *bounding-box-list*
	(print "debug")
	(if (equal found 1)
	  (progn (kick)
			 (setq found 0)
			 (nao-default-pose)
			 (lookaround))
	  (progn (cond
			   ((equal neckstate 0)
				(send *nao* :head :angle-vector #f(20 20))
				(send *ri* :angle-vector (send *nao* :angle-vector)))
			   ((equal neckstate 1)
				(send *nao* :head :angle-vector #f(0 20))
				(send *ri* :angle-vector (send *nao* :angle-vector)))
			   ((equal neckstate 2)
				(send *nao* :head :angle-vector #f(-20 20))
				(send *ri* :angle-vector (send *nao* :angle-vector)))
			   ((equal neckstate 3)
				(send *nao* :head :angle-vector #f(0 20))
				(send *ri* :angle-vector (send *nao* :angle-vector))))
			 (setq  neckstate (+ neckstate 1))
			 (send *ri* :wait-interpolation)
			 (if (< 3 neckstate)
			   (setq neckstate 0)))))
  )

(ros::subscribe *topic-name* jsk_recognition_msgs::BoundingBoxArray #'bounding-box-array-cb 1)
(do-until-key
  (x::window-main-one)
  (ros::spin-once)
  (ros::sleep)
  )

